\documentclass[a4paper,12pt,titlepage,finall]{article}

\usepackage[T1,T2A]{fontenc}     % форматы шрифтов
\usepackage[utf8x]{inputenc}     % кодировка символов, используемая в данном файле
\usepackage[russian]{babel}      % пакет русификации
\usepackage{tikz}                % для создания иллюстраций
\usepackage{pgfplots}            % для вывода графиков функций
\usepackage{geometry}		 % для настройки размера полей
\usepackage{indentfirst}         % для отступа в первом абзаце секции
\usepackage{multirow}            % для таблицы с результатами

% выбираем размер листа А4, все поля ставим по 3см
\geometry{a4paper,left=30mm,top=30mm,bottom=30mm,right=30mm}

\setcounter{secnumdepth}{0}      % отключаем нумерацию секций

\usepgfplotslibrary{fillbetween} % для изображения областей на графиках

\begin{document}
% Титульный лист
\begin{titlepage}
    \begin{center}
	{\small \sc Московский государственный университет \\имени М.~В.~Ломоносова\\
	Факультет вычислительной математики и кибернетики\\}
	\vfill
	{\Large \sc Отчет по заданию №1}\\
~\\
	{\large \bf <<Методы сортировки>>}\\ 
~\\
	{\large \bf Вариант 2 / 1 / 2 / 5}
    \end{center}
    \begin{flushright}
	\vfill {Выполнил:\\
	студент 104 группы\\
	Киперь~Д.~Ю.\\
~\\
	Преподаватели:\\
	Цыбров~Е.~Г.\\
    Кулагин~А.~В.}
    \end{flushright}
    \begin{center}
	\vfill
	{\small Москва\\2025}
    \end{center}
\end{titlepage}

% Автоматически генерируем оглавление на отдельной странице
\tableofcontents
\newpage

\section{Постановка задачи}
{\large Задание требовало от меня сделать следующее:}

\begin{itemize}
    \item написать генератор массивов длин 10, 100, 1000, 10000, элементами которых будут числа типа \textbf{long~long~int}; 
    \item сортировать числа в массивах в порядке неубывания;
    \item написать два алгоритма сортировок: Сортировка простым выбором и Пирамидальная сортировка;
    \item сделать посчет количества перестановок и сравнений в каждой из сортировок;
    \item провести эксперементальное сравнение двух алгоритмов сортировки;
\end{itemize}
\newpage


\section{Структура программы и определение функций}

Моя программа разделена на два модуля:
\begin{itemize}
    \item генератор массивов~(с случайными элементами типа \textbf{long long int}) для сортировки
    \item сортировщик массивов
\end{itemize}

В пераом модуле, как следует из названия, создаются и записываются в файлы массивы для сортировки.
В другом модуле реализовано считыване числе из файлов и запись их в массив, с последующей сортировкой
двумя типами сортировок, пирамидальной и простым выбором. Их результаты записываются в файлы
в каталог \textbf{output/``name of sort''}

\subsection{Генерация массивов}

Процесс генерации массивов включает в себя создание массива заданной длины с элементами типа \textbf{long long int}. \\
Так как длина массива может дозодить до 10000 то для удобства он будет сохранятся в отдельный файл.

\begin{verbatim}
FILE* file_open(char* filename, char* mode) {
    FILE* file = fopen(filename, mode);
    if (file == NULL) {
        if (strcmp("w", mode) == 0) {
            printf("Ошибка при открытии файла на запись!!\n");
        }

        if (strcmp("r", mode) == 0) {
            printf("Ошибка при открытии файла на чтение!!\n");
        }

        return NULL;
    }

    return file;
}
\end{verbatim}

Данная функция написана в генираторе чтобы при ошибке создания файл было выведено сообщение в консоли

\begin{verbatim}
void print_list(long long int* arr, int n) {
    for (int i = 0; i < n; i++) {
        printf("%lld ", arr[i]);
    }
}
\end{verbatim}

Эта вспомогательная функция выводит в консоль элементы массива (была написана для упрощенной отладки).

\begin{verbatim}
long long int get_rand_number() {
    return ((long long int)rand() << 32) | rand();
}
\end{verbatim}

Эта функция генерирует случайное число, которое будет использована для заполнения массива.

\begin{verbatim}
long long int* generate_array(int n) {
    long long int* arr = (long long int*) malloc(sizeof(long long int) * n);

    for (int i = 0; i < n; i++) {
        arr[i] = get_rand_number();

        while (arr[i] >= LLONG_MAX - BORDER || arr[i] <= LLONG_MIN + BORDER) {
            arr[i] = get_rand_number();
        }
    }

    return arr;
}

long long int* generate_sorted_array(int n) {
    long long int* arr = (long long int*) malloc(sizeof(long long int*) * n);

    arr[0] = get_rand_number();
    for (int i = 1; i < n; i++) {
        int ost = get_rand_number() % 10;
        
        while (ost == 0) {
            ost = get_rand_number() % 10;
        }

        arr[i] = arr[i - 1] + ost;
    }

    return arr;
}
\end{verbatim}

\newpage

\begin{verbatim}
long long int* generate_rotated_sorted_array(int n) {
    long long int* arr = (long long int*) malloc(sizeof(long long int*) * n);

    arr[0] = get_rand_number();
    for (int i = 1; i < n; i++) {
        int ost = get_rand_number() % 10;
        
        while (ost == 0) {
            ost = get_rand_number() % 10;
        }

        arr[i] = arr[i - 1] - ost;
    }

    return arr;
}
\end{verbatim}

Эти три функции обеспечивают генерацию трех массивов (в несортирванном, сортированном, сортированном в обратном порядке).
Память под каждый массив выделяется динамически, и в массив помещаются случайные числа типа \textbf{long~long~int}.

\begin{verbatim}
void create_file(
    char* filename,
    char* filname_sorted,
    char* filename_rotated_sorted,
    int n
) {
    long long int* arr = generate_array(n);
    long long int* sorted_arr = generate_sorted_array(n);
    long long int* rotated_sorted_arr = generate_rotated_sorted_array(n);

    FILE* file = file_open(filename, "w");
    FILE* file_sorted = file_open(filname_sorted, "w");
    FILE* file_rotated_sorted = file_open(filename_rotated_sorted, "w");

    for (int i = 0; i < n; i++) {
        fprintf(file, "%lld\n", arr[i]);
    }

    for (int i = 0; i < n; i++) {
        fprintf(file_sorted, "%lld\n", sorted_arr[i]);
    }

    for (int i = 0; i < n; i++) {
        fprintf(file_rotated_sorted, "%lld\n", rotated_sorted_arr[i]);
    }

    fclose(file);
    fclose(file_sorted);
    fclose(file_rotated_sorted);

    free(arr);
    free(sorted_arr);
    free(rotated_sorted_arr);
}
\end{verbatim}

Эта функция принимает имя файлов (несортированного, отсортированного и сортированного в обратном опрядке) и размер каждого из массивов.
После создаются файлы, и происходит запись данных из массивов в файлы. После чистим память.

\begin{verbatim}
void generate_data() {
    int num_params[] = { SMALL_NUM, LITTLE_NUM, MIDDLE_NUM, BIG_NUM };
    int len = sizeof(num_params) / sizeof(num_params[0]);

    for (int i = 0; i < len; i++) {
        char filename[MAX_BUF_SIZE];
        char filename_sorted[MAX_BUF_SIZE];
        char filename_rotated_sorted[MAX_BUF_SIZE];

        sprintf(
            filename,
            "%sunsorted%d.txt",
            INPUT_CATALOG,
            num_params[i]
        );
        sprintf(
            filename_sorted,
            "%ssorted%d.txt",
            INPUT_CATALOG,
            num_params[i]
        );
        sprintf(
            filename_rotated_sorted,
            "%srotated_sorted%d.txt",
            INPUT_CATALOG,
            num_params[i]
        );

        create_file(
            filename,
            filename_sorted,
            filename_rotated_sorted,
            num_params[i]
        );
    }
}
\end{verbatim}

Является одной из основных функций в генераторе, ибо явлется корнем создания фалов.
Она отвечает за создание имен файлов, и вызов функции, которая создает файлы с таким именем и числом параметров.

\begin{verbatim}
int main(void) {
    srand(time(NULL));

    generate_data();

    return 0;
}
\end{verbatim}

Эта функция является входной точкой всего генератора.
В ней мы подключаем возможность генерировать случайные числа,
а затем вызываем функцию, которая генерирует данные и записывает их в файлы.

\newpage

\subsection{Сортировки}

Моей задачей было реализовать сортировку простым выбором и пирамидальную сортировку.

\subsection{Сортировка простым выбором}

Суть сортировки простым выбором заключается в том, что сначала мы проходимся по всему массиву, находим
в нем максимальный элемент и меняем его с элементом, стоящим в конце массива. Далее сдвигаемся с конца массива на 1 влево
и проделываем то же самое, только максимальный эл-т ищется до n - 2 индекса(включительно),
а так же менятеся местами с эл-ом с индексом n - 2. Реализация такого алгоритма приложена ниже.

\begin{verbatim}
void selection_sort(long long int* arr, int n) {
    int j = n - 1;
    int max_i = 0;

    int compare = 0, transp = 0;

    for (int i = 0; i < n; i++) {
        for (int q = 0; q <= j; q++) {
            compare++;

            if (arr[q] > arr[max_i]) {
                max_i = q;  
            }
        }

        swap(&arr[max_i], &arr[j]);
        transp++;

        j--;
        max_i = 0;
    }

    printf(
        "Selection sort, размер массива - %d\n\tКоличество сравнений - %d,
         количество перестаовок - %d\n",
        n,
        compare,
        transp
    );
}
\end{verbatim}






\newpage


\section{Результаты экспериментов}

\hspace{5mm} После написания программы и ее запуска на входных тестах я получил следующие результаты:

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{\textbf{n}} & \multirow{2}{*}{\textbf{Параметр}} & \multicolumn{4}{|c|}{\textbf{Номер сгенерированного массива}} & \textbf{Среднее} \\
    \cline{3-6}
    & & \parbox{1.5cm}{\centering 1} & \parbox{1.5cm}{\centering 2} & \parbox{1.5cm}{\centering 3} & \textbf{значение} \\
    \hline
    \multirow{2}{*}{10} & Сравнения & & & & & \\
    \cline{2-7}
                        & Перемещения & & & & & \\
    \hline
    \multirow{2}{*}{100} & Сравнения & & & & & \\
    \cline{2-7}
                         & Перемещения & & & & & \\
    \hline
    \multirow{2}{*}{1000} & Сравнения & & & & & \\
    \cline{2-7}
                          & Перемещения & & & & & \\
    \hline
    \multirow{2}{*}{10000} & Сравнения & & & & & \\
    \cline{2-7}
                           & Перемещения & & & & & \\
    \hline
\end{tabular}
\caption{Результаты работы сортировки ...}
\end{table}

\newpage

\section{Структура программы и спецификация функций}

В данном разделе необходимо привести полный список функций,
описать их функциональность.

\newpage

\section{Отладка программы, тестирование функций}

В данном разделе необходимо изложить, как именно производилось тестирование
и отладка методов сортировки. Тестирование предполагает наличие как минимум
трех тестов.

\newpage

\section{Анализ допущенных ошибок}

\newpage
\begin{raggedright}
\addcontentsline{toc}{section}{Список цитируемой литературы}
\begin{thebibliography}{99}
\bibitem{cs} Кормен Т., Лейзерсон Ч., Ривест Р, Штайн К. Алгоритмы: построение и анализ.
    Второе издание.~--- М.:<<Вильямс>>, 2005.
\end{thebibliography}
\end{raggedright}


\end{document}
